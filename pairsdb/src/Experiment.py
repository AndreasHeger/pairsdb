####
####
##
## Project PythonTools
##
## Copyright (C) 2002 Andreas Heger All rights reserved
##
## Author: Andreas Heger <heger@ebi.ac.uk>
##
## $Id: Experiment.py,v 1.1 2002/11/18 13:00:34 heger Exp $
##
##
####
####

"""Module that contains some useful functions for
making experiments.
"""

import string,re,sys,time,inspect,getopt,os

global_starting_time = time.time()
global_options = None
global_args    = None

def GetHeader():
    """return a header string with command line options and
    timestamp"""
    return "# output generated by " + string.join(sys.argv, " ") + "\n" +\
           "# job started at " + time.asctime(time.localtime(time.time()))

def GetParams( options = None):
    """return a string containing script parameters.
    Parameters are all variables that start with "param_".
    """
    result = []
    if options:
        members = options.__dict__
        for k, v in members.items():
            result.append("# %-40s: %s" % (k, str(v).encode("string_escape")))
    else:
        vars = inspect.currentframe().f_back.f_locals
        for var in filter(lambda x: re.match("param_",x), vars.keys()):
            result.append("# %-40s: %s" % (var, str(vars[var]).encode("string_escape")))

    if result:
        return string.join(result, "\n")
    else:
        return "# no parameters."


def GetFooter():
    """return a header string with command line options and
    timestamp."""
    return "# job finished in %i seconds at %s -- %s" %\
           (time.time() - global_starting_time,
            time.asctime(time.localtime(time.time())),
            string.join( map( lambda x: "%5.2f" % x, os.times()[:4]), " "))

def Start( parser,
           quiet = False,
           add_csv_options = False,
           add_mysql_options = False,
           add_psql_options = False,
           add_pipe_options = True):
    """set up an experiment."""
    
    global global_options, global_args

    parser.add_option("-v", "--verbose", dest="loglevel", type="int",
                      help="loglevel. The higher, the more output." )

    if quiet:
        parser.set_defaults( loglevel = 0 )
    else:
        parser.set_defaults( loglevel = 1 )

    if add_csv_options:
        parser.add_option("-I", "--dialect", dest="csv_dialect", type="string",
                          help="csv dialect to use." )

        parser.set_defaults(
            csv_dialect = "excel-tab",
            csv_lineterminator = "\n",
            )

    if add_psql_options:
        parser.add_option("-C", "--connection", dest="connection", type="string",
                          help="psql connection string."  )
        parser.set_defaults( connection = "db:andreas" )

    if add_pipe_options:
        parser.add_option("-L", "--log", dest="stdlog", type="string",
                          help="file with logging information [default = stdout].",
                          metavar = "FILE"  )
        parser.add_option("-E", "--error", dest="stderr", type="string",
                          help="file with error information [default = stderr].",
                          metavar = "FILE"  )
        parser.add_option("-S", "--stdout", dest="stdout", type="string",
                          help="file where output is to go [default = stdout].",
                          metavar = "FILE"  )
        
        parser.set_defaults( stderr = sys.stdout )
        parser.set_defaults( stdout = sys.stdout )
        parser.set_defaults( stdlog = sys.stdout )
        
    if add_mysql_options:
        parser.add_option("-H", "--host", dest="host", type="string",
                          help="mysql host."  )
        parser.add_option("-D", "--database", dest="database", type="string",
                          help="mysql database."  )
        parser.add_option("-U", "--user", dest="user", type="string",
                          help="mysql username."  )
        parser.add_option("-P", "--password", dest="password", type="string",
                          help="mysql password."  )
        parser.add_option("-O", "--port", dest="port", type="int",
                          help="mysql port."  )
        
        parser.set_defaults( host = "db",
                             port = 3306,
                             user = "",
                             password = "",
                             database = "" )

    (global_options, global_args) = parser.parse_args()

    if add_pipe_options:
        if global_options.stdout != sys.stdout: 
            global_options.stdout = open(global_options.stdout, "w")
        if global_options.stderr != sys.stdout:
            if global_options.stderr == "stderr":
                global_options.stderr = global_options.stderr
            else:
                global_options.stderr = open(global_options.stderr, "w")
        if global_options.stdlog != sys.stdout:
            global_options.stdlog = open(global_options.stdlog, "a")            
    else:
        global_options.stderr = sys.stderr
        global_options.stdout = sys.stdout
        global_options.stdlog = sys.stdout
    
    if global_options.loglevel >= 1:
        global_options.stdlog.write(GetHeader() + "\n" )
        global_options.stdlog.write(GetParams( global_options) + "\n")
        global_options.stdlog.flush()
        
    return global_options, global_args
    
def Stop():
    """stop the experiment."""

#     if parser.has_option( "stderr" ):
#         if global_options.stderr != sys.stderr: global_options.stderr.close()
        
#     if parser.has_option( "stdout" ):
#         if global_options.stdout != sys.stdout: global_options.stdout.close()        
    
    if global_options.loglevel >= 1:
        global_options.stdlog.write(GetFooter() + "\n")

class Experiment:

    mShortOptions = ""
    mLongOptions  = []

    mLogLevel = 0
    mTest = 0
    mDatabaseName = None

    mName = sys.argv[0]

    def __init__(self):

        # process command-line arguments
        (self.mOptlist, self.mArgs) = self.ParseCommandLine()

        # set options now
        self.ProcessOptions(self.mOptlist)

    def DumpParameters( self ):
        """dump parameters of this object. All parameters start with a lower-case m."""

        members = self.__dict__

	print "#--------------------------------------------------------------------------------------------"
        print "#" + string.join(sys.argv)
        print "# pid: %i, system:" % os.getpid(), string.join(os.uname(), ",") 
	print "#--------------------------------------------------------------------------------------------"
        print "# Parameters for instance of <" + self.mName + "> on " + time.asctime(time.localtime(time.time()))

        member_keys = list(members.keys())
        member_keys.sort()
        for member in member_keys:
            if member[0] == 'm':
                print "# %-40s:" % member, members[member]

	print "#--------------------------------------------------------------------------------------------"
        sys.stdout.flush()

    #-----------------------------> Control functions <--------------------------------

    ##------------------------------------------------------------------------------------
    def ProcessOptions( self, optlist ):
        """Sets options in this module. Please overload as necessary."""

        for o,a in optlist:
            if o in ( "-V", "--Verbose" ):
                self.mLogLevel = string.atoi(a)
            elif o in ( "-T", "--test") :
                self.mTest = 1

    ##------------------------------------------------------------------------------------        
    def ProcessArguments( self, args ):
        """Perform actions as given in command line arguments."""

        if self.mLogLevel >= 1:
            self.DumpParameters()
            
        for arg in args:
            if arg[-1] == ")":
                statement = "self.%s" % arg
            else:
                statement = "self.%s()" % arg
            exec statement

            if self.mLogLevel >= 1:
                print "--------------------------------------------------------------------------------------------"
                print statement + " finished at " + time.asctime(time.localtime(time.time()))
                print "--------------------------------------------------------------------------------------------"

    ##------------------------------------------------------------------------------------            
    def ParseCommandLine( self ):
        """Call subroutine with command line arguments."""

        self.mShortOptions = self.mShortOptions + "V:D:T"
        self.mLongOptions.append( "Verbose=" )
        self.mLongOptions.append( "Database=" )
        self.mLongOptions.append( "Test" )

        try:
            optlist, args = getopt.getopt(sys.argv[1:],
                                          self.mShortOptions,
                                          self.mLongOptions)
        except getopt.error, msg:
            self.PrintUsage()
            print msg
            sys.exit(2)

        return optlist, args

    #--------------------------------------------------------------------------------        
    def Process( self ):
        self.ProcessArguments(self.mArgs)

    #--------------------------------------------------------------------------------
    def PrintUsage( self ):
        """print usage information."""

        print "# valid short options are:", self.mShortOptions
        print "# valid long options are:", str(self.mLongOptions)

    
