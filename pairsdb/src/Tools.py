####
####
##
## Project PairsDB
##
## Copyright (C) 2002 Andreas Heger All rights reserved
##
## Author: Andreas Heger <heger@ebi.ac.uk>
##
## $Id: Tools.py,v 1.1.1.1 2002/07/02 10:46:57 heger Exp $
##
##
####
####


#----------------------------------------------------------------
# Name:		Tools
#--------------General Information-------------------------------
# File:		Tools.py
# Version:           1.0
# Description:	things, which I do not know to put so far
# Author:		Andreas Heger (heger@ebi.ac.uk)
#--------------Documentation-------------------------------------
#
#
#--------------Change History------------------------------------
# 24 Jan 2000	Created
# 
#
#----------------------------------------------------------------


#----------------------------------------
# Function:     CalculateHid
# Description:  retrieves the hid for a sequence
# Author     : Andreas Heger
# Created    : 24.1.2000
#----------------------------------------

import md5
import base64
import string
import time
import sys


def calculateHID ( sequence ):
    """calculate a hash identifier for a sequence using only printable characters."""

    # do the encryption
    h = md5.new(sequence).digest()
    
    # map to printable letters: hid has length 22, so the padded '=' are
    # truncated. You have to add them, if you ever want to decode,
    # but who would do such a thing :=)

    r = base64.encodestring(h)[0:22]

    # finally substitute some characters:
    # '/' for '_', so we have legal file names
    # '[' for '+' and ']' for '=' for internet-applications
    
    hid = string.replace(r  , '/', '_') 
    hid = string.replace(hid, '+', '[') 
    hid = string.replace(hid, '=', ']') 

    return hid
    

#----------------------------------------
# Function:     WriteFastaFile
# Description:  Write a query as fasta-file
#               the first fields go into the description line,
#               the last field is the sequence
# Author     : Andreas Heger
# Created    : 20.5.2000
#----------------------------------------
def WriteFastaFile( filename, query):

    file = open (filename , "w")
    while 1:
        entry = query.fetchone()
        if not entry: break
        last_element = len(entry) -1
        file.write( ">" )
        file.write( string.join( map( str, entry[:-1]) , " "))
        file.write( string.join( ("\n", entry[last_element], "\n"), ""))

    file.close()

#----------------------------------------
# Function:    AdvanceTo
# Description: advance in file until expression matches
#		and return line
# Author     : Andreas Heger
# Created    : 21.1.2000
#----------------------------------------
import re

def AdvanceTo( expression, file ):
    
    while 1:
	line = file.readline()
	if not line: break
	if re.search( expression, line): break
    return line
	
#----------------------------------------
# Function:    GetMysqlDate
# Description: retrieve the date and return it as string
#		in the format YYYY-MM-YY
# Author     : Andreas Heger
# Created    : 24.1.2000
#----------------------------------------
import time

def GetMysqlDate():
    return time.strftime("%Y-%m-%d", time.localtime(time.time()))


def GetTimeStamp():
    return time.asctime(time.localtime(time.time()))

	
#----------------------------------------
# Function:    WriteHeader
# Description: write a header
# Author     : Andreas Heger
# Created    : 1.8.2001
#----------------------------------------
def GetHeader():
    return "# output generated by " + string.join(sys.argv) +\
           " at " + time.asctime(time.localtime(time.time()))

#----------------------------------------
# Function:    CompressAlignmentRow
# Description: compress an alignment-string, supply gap-character
# Author     : Andreas Heger
# Created    : 14.9.2000
#----------------------------------------
def CompressAlignmentRow( alignment, gap_character = "-", ignore_beginning = 0 ):
    """compress an alignment string.
    Lower-case characters at the beginning are ignored if so wished.
    --xxabBCDEfgHI
    becomes:
    -6+4

    This was necessary for radar output (e.g., 46497)
    """

    # subsitute all initial lower case characters with a gap
    if ignore_beginning:
        x = re.search("[A-Z]", alignment)
        if x:
            alignment = gap_character * x.start() + alignment[x.start():] 
        
    d = 0
    if alignment[0] == gap_character:
        gap = 1
    else:
        gap = 0
        
    result = ""
    
    for char in alignment:
        if char == gap_character and not gap:
            result += "+%i" % d
            d = 1
            gap = 1
            continue

        if char != gap_character and gap:
            result += "-%i" % d
            d = 1
            gap = 0
            continue

        d = d + 1
        
    if gap:
        result = result + "-%i" % d
    else:
        result = result + "+%i" % d
        
    return result

#----------------------------------------
# Function:    CombineIntervallsLarge
# Description: combine a list of intervalls,
#              so that only the largest are kept
# Author     : Andreas Heger
# Created    : 14.9.2000
#----------------------------------------
def CombineIntervallsLarge( intervalls ):
    """combine intervalls. Smaller intervalls are
    subsumed into larger ones.
    """
    if not intervalls:
        return None

    new_intervalls = []
    
    intervalls.sort()
    first_from, last_to = intervalls[0]
    
    for this_from, this_to in intervalls[1:]:
        if this_from > last_to:
            new_intervalls.append( (first_from, last_to ) )
            first_from = this_from
            last_to = this_to
            continue

        if last_to < this_to:
            last_to = this_to
    
    new_intervalls.append( ( first_from, last_to ))

    return new_intervalls

#----------------------------------------
def CombineIntervallsDistance( intervalls, min_distance ):
    """ combine a list of non-overlapping intervalls,
    and merge those that are less than a certain
    distance apart.
    """
    
    if not intervalls:
        return None

    new_intervalls = []
    
    intervalls.sort()
    first_from, last_to = intervalls[0]
    
    for this_from, this_to in intervalls[1:]:
        
        if (last_to + min_distance) < this_from:
            new_intervalls.append( (first_from, last_to ) )
            first_from = this_from

        last_to = this_to
    
    new_intervalls.append( ( first_from, last_to ))

    return new_intervalls


def SplitFastaFile( input_filename, chunk_size ):
    """split input_filename into chunks of chunk_size lines.
    """

    infile = open(input_filename, "r")

    index = 0
    nentities = 0
    result = []

    new_filename = input_filename + "_" + str(index)
    result.append(new_filename)
    outfile = open( new_filename, "w" )

    while 1:
        
        line = infile.readline()
        if not line: break
        
        if line[0] == ">":
            nentities += 1
            if nentities > chunk_size:
                nentities = 1
                index += 1
                
                outfile.close()
                new_filename = input_filename + "_" + str(index)
                result.append(new_filename)
                outfile = open( new_filename, "w" )
                
        outfile.write(line)

    outfile.close()

    return result
        
#--------------------------------------------------------------------------------
def MapRight( mapping, row_residue ):
    """return mapping of row_residue. Go right, if not found."""
    col_residue = mapping.mapRowToCol( row_residue )

    max_residue = mapping.getRowTo()

    while col_residue == 0:
        row_residue = row_residue + 1
        if row_residue > max_residue:
            return (0)

        col_residue = mapping.mapRowToCol( row_residue )

    return (col_residue)

#--------------------------------------------------------------------------------
def MapLeft( mapping, row_residue ):
    """return mapping of row_residue. Go left, if not found."""
    col_residue = mapping.mapRowToCol( row_residue )

    min_residue = mapping.getRowFrom()

    while col_residue == 0:
        row_residue = row_residue - 1
        if row_residue < min_residue:
            return (0)

        col_residue = mapping.mapRowToCol( row_residue )

    return (col_residue)

#--------------------------------------------------------------------------------
def CalculateAlignmentLength( alignment ):
    """calculates the length of an alignment based on an
    alignment string.
    """
    values = re.split("[+\-]", alignment[1:] )
    return reduce( lambda x, y: x + y, map( string.atoi, values))





